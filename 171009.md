# 09.10.2017
Сегодня --- рассказ про вещи, которые делают скалу скалой.
Знакомимся с implicit'ам.
Пообсуждаем import'ы, package'и (отдельная большая фича) и систему типов (не без хардкора).

## Синтаксис вызова методов - increase
Начнём с примеров.

Как писали код давно?
1. Вместо классов --- структуры с публичными полями и функции, которым первым параметром передают структуру.
2. Потом переместили функцию внутрь структуры и сделали первый параметр *неявным* this.

Какие ещё бывают неявные плюшки?
1. Проперти.
2. Статические функции.

Новая проблема: пусть есть метод, который работает только через публичный интерфейс.
Тогда внутри класса его некруто писать, напишем его в companion object (привет от increase).
Получаем, что статический метод делегировался в публичный.

## Implicit classes, AnyVal - mkString
mkString - утилитный метод, который бы хорошо запускать на произвольных коллекциях.
Можно его написать статическим, но тогда будет синтаксис неудобный.
Решение --- extension-методы (есть в Scala, C#, Kotlin).
package object/implicit class

Так писать прикольно, но это входит в некоторую конфронтацию с тем, что extension выглядит, как метод, но методом не является.

Что делает implicit class(val struct: Struct)? Он заменяет строчку
struct.increase(Seq(1, 2, 3))
на
new StructExt(struct).increase(Seq(1, 2, 3))
То есть он его неявно конструирует. Прям вообще неявно. Это как-то не очень круто.

Но если мы сделаем implicit class(val struct: Struct) extends AnyVal, то мы как бы "сконструируем объект на стеке".
Так как в JVM совсем конструирования на стеке нет, на самом деле мы добавляем ограничение "отсутствуют property у объекта", а методы превратились в статические методы. Нам пофиг --- у нас только метод. Значит, теперь конструирование объекта не будет совершаться, что хорошо.

## Implicit conversion
Пусть вы используете два фреймворка, один даёт класс Foo, другой даёт класс Bar.
Смотрим на классы Foo и Bar. Они концептуально обозначают одно и то же.
Пусть есть полезный метод для класса Bar, хотим вызывать его для Foo.
Хотим неявную конвертацию. Сделать implicit class Bar тогда не получится.
Надо писать конвертер. Пишем его в package object (что это такое - см.ниже):
implicit def foo2Bar(foo: Foo): Bar = ???

## Package object
Синтаксис: лежит в пакете ....lecture06, называется lecture06.
В Scala, как и в Java, запрещено делать методы не внутри объектов/классов (в Kotlin можно делать top-level definition).
В Scala сделали package object. Это штука из двух частей:
1. Свалка как-бы-top-level-definition.
2. Внутри этого конкретного пакета автоматически импортируются все методы этого объекта. В частности, становятся доступными для implicit. В остальных пакетах можно методы импортировать явно.

# import'ы
Обычно джавовские коллекции никто на скале никогда не используется.
По если надо, можно заимпортировать:
import java.util.{List => JList}
Так обычно не пишут, пишут так:
import java.{util => ju}
Конвенция в Scala: писать имя последнего пакета, а потом класс: ju.List

Прикольная конверсия:
import ....JavaConversions._
Теперь автоматически скаловский List сконвертируется в java. Но это как-то неоч, потому что теперь куча неявных преобразований.
Лучше так:
import ....JavaConverters._
Тогда можно явно писать .asJava

А ещё лучше (потому что конверсии вряд ли нужны во всём файле):
import ....JavaConverters
А внутри метода --- `import JavaConverters._`

По умолчанию нельзя использовать методы companion object'а внутри класса.
Можно полечить (если у нас класс Struct):
import Struct._
Приватность между companion object/class общая.
Но можно в companion object написать private[this], тогда будет совсем-совсем приватно.

Ещё при импортах можно скрывать классы и пакеты (но зачем?):
import java.{rmi => _}
Затем: https://stackoverflow.com/questions/2871822/how-do-i-exclude-rename-some-classes-from-import-in-scala
import java.util.{ArrayList => _, _}

# type alias
`type foo = Seq[int]`
`type foo[K] = Seq[k]`
Это просто using. Их тоже можно импортировать.

А ещё он же используется для AbstractMemberType. Это более заумный синтаксис, чем шаблоны.